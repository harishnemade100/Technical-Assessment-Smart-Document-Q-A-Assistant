{"version":3,"sources":["../../../../src/client/components/segment-cache-impl/lru.ts"],"sourcesContent":["import type { MapEntry } from './cache-map'\nimport { deleteFromCacheMap } from './cache-map'\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n\n// The MapEntry type is used as an LRU node, too. We choose this one instead of\n// the inner cache entry type (RouteCacheEntry, SegmentCacheEntry) because it's\n// monomorphic and can be optimized by the VM.\ntype LRUNode = MapEntry<any, any>\n\nlet head: LRUNode | null = null\nlet didScheduleCleanup: boolean = false\nlet lruSize: number = 0\n\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxLruSize = 50 * 1024 * 1024 // 50 MB\n\nexport function lruPut(node: LRUNode) {\n  if (head === node) {\n    // Already at the head\n    return\n  }\n  const prev = node.prev\n  const next = node.next\n  if (next === null || prev === null) {\n    // This is an insertion\n    lruSize += node.size\n    // Whenever we add an entry, we need to check if we've exceeded the\n    // max size. We don't evict entries immediately; they're evicted later in\n    // an asynchronous task.\n    ensureCleanupIsScheduled()\n  } else {\n    // This is a move. Remove from its current position.\n    prev.next = next\n    next.prev = prev\n  }\n\n  // Move to the front of the list\n  if (head === null) {\n    // This is the first entry\n    node.prev = node\n    node.next = node\n  } else {\n    // Add to the front of the list\n    const tail = head.prev\n    node.prev = tail\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      tail.next = node\n    }\n    node.next = head\n    head.prev = node\n  }\n  head = node\n}\n\nexport function updateLruSize(node: LRUNode, newNodeSize: number) {\n  // This is a separate function from `put` so that we can resize the entry\n  // regardless of whether it's currently being tracked by the LRU.\n  const prevNodeSize = node.size\n  node.size = newNodeSize\n  if (node.next === null) {\n    // This entry is not currently being tracked by the LRU.\n    return\n  }\n  // Update the total LRU size\n  lruSize = lruSize - prevNodeSize + newNodeSize\n  ensureCleanupIsScheduled()\n}\n\nexport function deleteFromLru(deleted: LRUNode) {\n  const next = deleted.next\n  const prev = deleted.prev\n  if (next !== null && prev !== null) {\n    lruSize -= deleted.size\n\n    deleted.next = null\n    deleted.prev = null\n\n    // Remove from the list\n    if (head === deleted) {\n      // Update the head\n      if (next === head) {\n        // This was the last entry\n        head = null\n      } else {\n        head = next\n      }\n    } else {\n      prev.next = next\n      next.prev = prev\n    }\n  } else {\n    // Already deleted\n  }\n}\n\nfunction ensureCleanupIsScheduled() {\n  if (didScheduleCleanup || lruSize <= maxLruSize) {\n    return\n  }\n  didScheduleCleanup = true\n  requestCleanupCallback(cleanup)\n}\n\nfunction cleanup() {\n  didScheduleCleanup = false\n\n  // Evict entries until we're at 90% capacity. We can assume this won't\n  // infinite loop because even if `maxLruSize` were 0, eventually\n  // `deleteFromLru` sets `head` to `null` when we run out entries.\n  const ninetyPercentMax = maxLruSize * 0.9\n  while (lruSize > ninetyPercentMax && head !== null) {\n    const tail = head.prev\n    // In practice, this is never null, but that isn't encoded in the type\n    if (tail !== null) {\n      // Delete the entry from the map. In turn, this will remove it from\n      // the LRU.\n      deleteFromCacheMap(tail.value)\n    }\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n"],"names":["deleteFromLru","lruPut","updateLruSize","head","didScheduleCleanup","lruSize","maxLruSize","node","prev","next","size","ensureCleanupIsScheduled","tail","newNodeSize","prevNodeSize","deleted","requestCleanupCallback","cleanup","ninetyPercentMax","deleteFromCacheMap","value","requestIdleCallback","cb","setTimeout"],"mappings":";;;;;;;;;;;;;;;;IAyEgBA,aAAa;eAAbA;;IArDAC,MAAM;eAANA;;IAuCAC,aAAa;eAAbA;;;0BA1DmB;AAUnC,IAAIC,OAAuB;AAC3B,IAAIC,qBAA8B;AAClC,IAAIC,UAAkB;AAEtB,+EAA+E;AAC/E,0EAA0E;AAC1E,4CAA4C;AAC5C,MAAMC,aAAa,KAAK,OAAO,KAAK,QAAQ;;AAErC,SAASL,OAAOM,IAAa;IAClC,IAAIJ,SAASI,MAAM;QACjB,sBAAsB;QACtB;IACF;IACA,MAAMC,OAAOD,KAAKC,IAAI;IACtB,MAAMC,OAAOF,KAAKE,IAAI;IACtB,IAAIA,SAAS,QAAQD,SAAS,MAAM;QAClC,uBAAuB;QACvBH,WAAWE,KAAKG,IAAI;QACpB,mEAAmE;QACnE,yEAAyE;QACzE,wBAAwB;QACxBC;IACF,OAAO;QACL,oDAAoD;QACpDH,KAAKC,IAAI,GAAGA;QACZA,KAAKD,IAAI,GAAGA;IACd;IAEA,gCAAgC;IAChC,IAAIL,SAAS,MAAM;QACjB,0BAA0B;QAC1BI,KAAKC,IAAI,GAAGD;QACZA,KAAKE,IAAI,GAAGF;IACd,OAAO;QACL,+BAA+B;QAC/B,MAAMK,OAAOT,KAAKK,IAAI;QACtBD,KAAKC,IAAI,GAAGI;QACZ,sEAAsE;QACtE,IAAIA,SAAS,MAAM;YACjBA,KAAKH,IAAI,GAAGF;QACd;QACAA,KAAKE,IAAI,GAAGN;QACZA,KAAKK,IAAI,GAAGD;IACd;IACAJ,OAAOI;AACT;AAEO,SAASL,cAAcK,IAAa,EAAEM,WAAmB;IAC9D,yEAAyE;IACzE,iEAAiE;IACjE,MAAMC,eAAeP,KAAKG,IAAI;IAC9BH,KAAKG,IAAI,GAAGG;IACZ,IAAIN,KAAKE,IAAI,KAAK,MAAM;QACtB,wDAAwD;QACxD;IACF;IACA,4BAA4B;IAC5BJ,UAAUA,UAAUS,eAAeD;IACnCF;AACF;AAEO,SAASX,cAAce,OAAgB;IAC5C,MAAMN,OAAOM,QAAQN,IAAI;IACzB,MAAMD,OAAOO,QAAQP,IAAI;IACzB,IAAIC,SAAS,QAAQD,SAAS,MAAM;QAClCH,WAAWU,QAAQL,IAAI;QAEvBK,QAAQN,IAAI,GAAG;QACfM,QAAQP,IAAI,GAAG;QAEf,uBAAuB;QACvB,IAAIL,SAASY,SAAS;YACpB,kBAAkB;YAClB,IAAIN,SAASN,MAAM;gBACjB,0BAA0B;gBAC1BA,OAAO;YACT,OAAO;gBACLA,OAAOM;YACT;QACF,OAAO;YACLD,KAAKC,IAAI,GAAGA;YACZA,KAAKD,IAAI,GAAGA;QACd;IACF,OAAO;IACL,kBAAkB;IACpB;AACF;AAEA,SAASG;IACP,IAAIP,sBAAsBC,WAAWC,YAAY;QAC/C;IACF;IACAF,qBAAqB;IACrBY,uBAAuBC;AACzB;AAEA,SAASA;IACPb,qBAAqB;IAErB,sEAAsE;IACtE,gEAAgE;IAChE,iEAAiE;IACjE,MAAMc,mBAAmBZ,aAAa;IACtC,MAAOD,UAAUa,oBAAoBf,SAAS,KAAM;QAClD,MAAMS,OAAOT,KAAKK,IAAI;QACtB,sEAAsE;QACtE,IAAII,SAAS,MAAM;YACjB,mEAAmE;YACnE,WAAW;YACXO,IAAAA,4BAAkB,EAACP,KAAKQ,KAAK;QAC/B;IACF;AACF;AAEA,MAAMJ,yBACJ,OAAOK,wBAAwB,aAC3BA,sBACA,CAACC,KAAmBC,WAAWD,IAAI","ignoreList":[0]}